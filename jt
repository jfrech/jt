#! /bin/zsh

# Jonathan Frech, April to June 2020

jt_repository=""
jt_local="$(dirname "$0")"


fail () {
    printf "\33[1m\33[94mjt error:\33[0m " >&2
    echo "$@" >&2
    exit 1 }

require () {
    for cmd in "$@"; do
        [ -z "$(command -v $cmd)" ] \
            && fail "require (): Please install '$cmd'."
    done }
require realpath dirname
require mv rm mkdir rmdir
require printf echo
require grep sed
require curl tar
require make gcc chmod
require xargs

for_all_tools () {
    [ ! "$#" = '1' ] && fail 'for_all_tools (): Invalid arg count.'
    curl --silent --fail "$jt_repository/toolbox/tools.txt" | \
        while read ln; do
            "$1" "$ln";
        done }


list_line () {
    tool="$1"
    printf '['
    # downloaded, extracted, has Makefile, built
    [ -f "$jt_local/toolbox/$tool.tar.gz"   ] && printf 'd' || printf -- '-'
    [ -d "$jt_local/toolbox/$tool"          ] && printf 'x' || printf -- '-'
    [ -f "$jt_local/toolbox/$tool/Makefile" ] && printf 'M' || printf -- '-'
    [ -f "$jt_local/toolbox/$tool/$tool"    ] && printf 'b' || printf -- '-'
    printf '] %s\n' "$tool" }
list () {
    for_all_tools list_line }

download () {
    [ ! "$#" = '1' ] && fail 'download (): Invalid arg count.'
    tool="$1"
    [ "$tool" = 'all' ] && for_all_tools download && return 0

    [ -f "$jt_local/toolbox/$tool.tar.gz" ] && return 0

    mkdir -p "$jt_local/.download"
    curl --fail --silent "$jt_repository/toolbox/$tool.tar.gz" \
        > "$jt_local/.download/$tool.tar.gz" \
        || fail "download (): Failed to download '$tool'."

    mkdir -p "$jt_local/toolbox"
    mv "$jt_local/.download/$tool.tar.gz" "$jt_local/toolbox/$tool.tar.gz" }

extract () {
    [ ! "$#" = '1' ] && fail 'extract (): Invalid arg count.'
    tool="$1"
    [ "$tool" = 'all' ] && for_all_tools extract && return 0

    [ -d "$jt_local/toolbox/$tool" ] && return 0
    [ ! -f "$jt_local/toolbox/$tool.tar.gz" ] && download "$tool"

    tar -xf "$jt_local/toolbox/$tool.tar.gz" -C "$jt_local/toolbox" }

build () {
    [ ! "$#" = '1' ] && fail 'build (): Invalid arg count.'
    tool="$1"
    [ "$tool" = 'all' ] && for_all_tools build && return 0

    [ -f "$jt_local/toolbox/$tool/$tool" ] && return 0
    [ ! -d "$jt_local/toolbox/$tool" ] && extract "$tool"

    [ -f "$jt_local/toolbox/$tool/Makefile" ] \
        && make --silent -C "$jt_local/toolbox/$tool" > /dev/null

    [ ! -f "$jt_local/toolbox/$tool/$tool" ] \
        && fail "build (): Could not unpack '$tool'."
    chmod +x "$jt_local/toolbox/$tool/$tool" }

run () {
    [ -z "$1" ] && fail 'run (): Invalid arg count.'
    tool="$1"
    [ "$tool" = 'all' ] && fail 'run (): Refusing to run all tools.'

    [ ! -f "$jt_local/toolbox/$tool/$tool" ] && build "$tool"

    [ ! -f "$jt_local/toolbox/$tool/$tool" ] \
        && fail "run (): Could not find tool '$tool'."
    "$jt_local/toolbox/$tool/$tool" ${@:2} }

remove () {
    [ ! "$#" = '1' ] && fail 'remove (): Invalid arg count.'
    tool="$1"
    [ "$tool" = 'all' ] && for_all_tools remove && return 0

    rm -rf "$jt_local/toolbox/$tool.tar.gz" "$jt_local/toolbox/$tool" }

update_self () {
    mkdir -p "$jt_local/.download"
    curl --fail --silent "$jt_repository/jt" \
        > "$jt_local/.download/jt" \
        || fail "update_self (): Failed to download 'jt'."

    mkdir -p "$jt_local"
    mv "$jt_local/.download/jt" "$jt_local/jt" }
update () {
    [ ! "$#" = '1' ] && fail 'update (): Invalid arg count.'
    tool="$1"
    [ "$tool" = 'all' ] && for_all_tools update && return 0
    [ "$tool" = 'self' ] && update_self && return 0

    rebuild=''
    [ -e "$jt_local/toolbox/$tool.tar.gz" ] && remove "$tool" && rebuild='j'
    [ -e "$jt_local/toolbox/$tool"        ] && remove "$tool" && rebuild='j'

    [ -n "$rebuild" ] && build "$tool" }

get () {
    fail 'get (): Not yet implemented.' }

help () {
    fail 'help (): Not yet implemented.' }

internal () {
    case "$1" in
        list)     list ${@:2} ;;

        download) download ${@:2} ;;
        extract)  extract ${@:2} ;;
        build)    build ${@:2} ;;
        run)      run ${@:2} ;;
        remove)   remove ${@:2} ;;
        update)   update ${@:2} ;;

        get)      get ${@:2} ;;
        help)     help ${@:2} ;;
        require)  require ${@:2} ;;
        *) fail "internal (): Unknown command '$1'." ;;
    esac }


[ "$1" = 'internal' ] && internal ${@:2}
[ ! "$1" = 'internal' ] && run $@

exit 0
