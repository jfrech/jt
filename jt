#! /bin/zsh

# Jonathan Frech, April to June 2020

jt_repository=""
jt_local="$(dirname "$0")"
tool=""


fail () {
    printf "\33[1m\33[94mjt error:\33[0m %s\n" "$*" >&2 && exit 1 }

require () {
    for cmd in "$@"; do
        [ -z "$(command -v $cmd)" ] \
            && fail "require (): Please install '$cmd'."
    done }

assure_tools_list () {
    [ -f "$jt_local/toolbox/tools.txt" ] && return 0
    curl --silent --fail "$jt_repository/toolbox/tools.txt" \
        > "$jt_local/.download/tools.txt"
    rm -rf "$jt_local/toolbox/tools.txt"
    mv "$jt_local/.download/tools.txt" "$jt_local/toolbox/tools.txt" }

for_all_tools () {
    [ ! "$#" = '1' ] && fail 'for_all_tools (): Invalid arg count.'
    assure_tools_list
    < "$jt_local/toolbox/tools.txt" | while read ln; do "$1" "$ln"; done }
enable_all_version () {
    f="$1" ; [ ! "$#" = '2' ] && fail "$f (): Invalid arg count."
    tool="$2" ; [ "$tool" = 'all' ] && for_all_tools "$f" && return 0
    "$f" }

list () {
    assure_tools_list
    ! grep -q "^$tool\$" "$jt_local/toolbox/tools.txt" \
        && fail "list (): Tool '$tool' does not exist."

    # [dxMb]: downloaded, extracted, has Makefile, built
    printf '['
    [ -f "$jt_local/toolbox/$tool.tar.gz"   ] && printf 'd' || printf -- '-'
    [ -d "$jt_local/toolbox/$tool"          ] && printf 'x' || printf -- '-'
    [ -f "$jt_local/toolbox/$tool/Makefile" ] && printf 'M' || printf -- '-'
    [ -f "$jt_local/toolbox/$tool/$tool"    ] && printf 'b' || printf -- '-'
    printf '] %s\n' "$tool" }

download () {
    [ -f "$jt_local/toolbox/$tool.tar.gz" ] && return 0

    mkdir -p "$jt_local/.download"
    curl --fail --silent "$jt_repository/toolbox/$tool.tar.gz" \
        > "$jt_local/.download/$tool.tar.gz" \
        || fail "download (): Failed to download '$tool'."

    mkdir -p "$jt_local/toolbox"
    mv "$jt_local/.download/$tool.tar.gz" "$jt_local/toolbox/$tool.tar.gz" }

extract () {
    [ -d "$jt_local/toolbox/$tool" ] && return 0
    [ ! -f "$jt_local/toolbox/$tool.tar.gz" ] && download "$tool"

    tar -xf "$jt_local/toolbox/$tool.tar.gz" -C "$jt_local/toolbox" }

build () {
    [ -f "$jt_local/toolbox/$tool/$tool" ] && return 0
    [ ! -d "$jt_local/toolbox/$tool" ] && extract "$tool"

    [ -f "$jt_local/toolbox/$tool/Makefile" ] \
        && make --silent -C "$jt_local/toolbox/$tool" > /dev/null

    [ ! -f "$jt_local/toolbox/$tool/$tool" ] \
        && fail "build (): Could not unpack '$tool'."
    chmod +x "$jt_local/toolbox/$tool/$tool" }

run () {
    [ -z "$1" ] && fail 'run (): Invalid arg count.'
    tool="$1" ; [ "$tool" = 'all' ] && fail 'run (): Refusing to run all tools.'

    [ ! -f "$jt_local/toolbox/$tool/$tool" ] && build "$tool"

    [ ! -f "$jt_local/toolbox/$tool/$tool" ] \
        && fail "run (): Could not find tool '$tool'."
    "$jt_local/toolbox/$tool/$tool" ${@:2} }

remove () {
    rm -rf "$jt_local/toolbox/$tool.tar.gz" "$jt_local/toolbox/$tool" }

update_self () {
    mkdir -p "$jt_local/.download"
    curl --fail --silent "$jt_repository/jt" \
        | sed "s|^jt_repository=\"[^\"]*\"\$|jt_repository=\"$jt_repository\"|" \
        > "$jt_local/.download/jt" \
        || fail "update_self (): Failed to download 'jt'."

    mkdir -p "$jt_local"
    mv "$jt_local/.download/jt" "$jt_local/jt"
    chmod +x "$jt_local/jt" }
update () {
    [ "$tool" = 'self' ] && update_self && return 0

    rebuild=''
    [ -e "$jt_local/toolbox/$tool.tar.gz" ] && remove "$tool" && rebuild='j'
    [ -e "$jt_local/toolbox/$tool"        ] && remove "$tool" && rebuild='j'

    [ -n "$rebuild" ] && build "$tool" && return 0

    fail "update (): Cannot update uninstalled tool '$tool'." }

get () {
    fail 'get (): Not yet implemented.' }

help () {
    fail 'help (): Not yet implemented.' }

internal () {
    rm -rf "$jt_local/toolbox/tools.txt"

    case "$1" in
        list)     enable_all_version list ${@:2} ;;

        download) enable_all_version download ${@:2} ;;
        extract)  enable_all_version extract ${@:2} ;;
        build)    enable_all_version build ${@:2} ;;
        remove)   enable_all_version remove ${@:2} ;;

        require)  require ${@:2} ;;

        # This command is questionable.
        update)   enable_all_version update ${@:2} ;;

        get)      get ${@:2} ;;
        help)     help ${@:2} ;;

        fail)     fail ${@:2} ;;
        *)        fail "internal (): Unknown command '$1'." ;;
    esac }


require realpath dirname mv rm mkdir rmdir printf grep sed curl tar make gcc \
    chmod xargs

case "$1" in
    internal) internal ${@:2} ;;
    *)        run $@ ;;
esac && exit 0
