#! /bin/zsh

jt="$(realpath "$(dirname "$0")/../../jt")"
fail () { "$jt" internal fail $@ ; exit 1 }

[ ! "$#" = '2' ] && fail "Need exactly two arguments."
src="$(realpath "$PWD/$1")" dst="$(realpath "$PWD/$2")"
[ ! -d "$src" ] && fail "Source needs to be a directory, not '$src'."
[ ! -d "$dst" ] && fail "Destination needs to be a directory, not '$dst'."

build_script () {
    src_f="$1" dst_f="$dst/$(realpath --relative-to="$src" "$1")"
    [ ! -e "$dst_f" ] \
        && printf 'mkdir -p "%q"\n' "$(dirname "$dst_f")" \
        && printf 'mv "%q" "%q"\n' "$src_f" "$dst_f" && return
    printf 'WIP\n' }

new_files=0 duplicate_files=0 collision_files=0 error_files=0
handle () {
    src_f="$1" dst_f="$dst/$(realpath --relative-to="$src" "$1")"
    [ ! -e "$dst_f" ] \
        && printf 'n "%q"\n' "$src_f" && ((new_files++)) && return
    [ -f "$dst_f" ] && cmp "$src_f" "$dst_f" >/dev/null \
        && printf 'd "%q"\n' "$src_f" && ((duplicate_files++)) && return
    [ -f "$dst_f" ] \
        && printf 'C "%q"\n' "$src_f" && ((collision_files++)) && return
    printf 'E %q\n' "$src_f" && ((error_files++)) && return }

printf '[Legend] n: new file, d: duplicate file, C: file collision, E: error\n'
find "$src" -type f | sort | while read f; do handle "$f"; done
printf 'new_files=%d, duplicate_files=%d, collision_files=%d, error_files=%d\n' \
    "$new_files" "$duplicate_files" "$collision_files" "$error_files"
